# 📊 통계 수집 표준화 가이드

## 📋 개요

이 문서는 SimPy 기반 제조 시뮬레이션 프레임워크에서 향상된 통계 수집 시스템의 사용법을 설명합니다. 새로운 표준화된 통계 시스템은 다음과 같은 기능을 제공합니다:

- **중앙 집중식 통계 관리**: 모든 컴포넌트의 통계를 중앙에서 관리
- **실시간 알림 시스템**: 임계값 기반 자동 알림
- **제조업 특화 KPI**: OEE, MTBF, MTTR 등 제조업 핵심 지표
- **성능 최적화**: 메모리 효율적인 데이터 관리
- **고급 분석**: 트렌드 분석, 이상치 감지, 예측 분석

---

## 🚀 시작하기

### 1. 기본 설정

#### SimPy 환경에서 중앙 통계 관리자 초기화

```python
import simpy
from src.core.centralized_statistics import CentralizedStatisticsManager

# SimPy 환경 생성
env = simpy.Environment()

# 중앙 통계 관리자 초기화
stats_manager = CentralizedStatisticsManager(
    env=env,
    max_components=1000,    # 최대 컴포넌트 수
    enable_alerts=True      # 알림 시스템 활성화
)
```

#### 컴포넌트별 통계 인터페이스 생성

```python
from src.core.centralized_statistics import StatisticsInterface

# 기계 컴포넌트용 통계 인터페이스
machine_stats = StatisticsInterface(
    component_id="machine_001",
    component_type="cnc_machine",
    stats_manager=stats_manager
)

# 작업자 컴포넌트용 통계 인터페이스
worker_stats = StatisticsInterface(
    component_id="worker_001",
    component_type="operator",
    stats_manager=stats_manager
)
```

---

## 📈 메트릭 기록 방법

### 1. 기본 메트릭 타입

#### 카운터 메트릭 (누적값)
- 총 생산량, 총 요청 수 등 계속 증가하는 값

```python
# 생산품 완료 시
machine_stats.record_counter("total_parts_produced")

# 요청 처리 시
machine_stats.record_counter("total_requests", increment=1)
```

#### 게이지 메트릭 (현재값)
- 현재 대기열 길이, 현재 온도 등 시점별 값

```python
# 현재 대기열 길이
machine_stats.record_gauge("queue_length", current_queue_length)

# 현재 가동률
machine_stats.record_gauge("utilization", current_utilization)
```

#### 히스토그램 메트릭 (분포값)
- 처리 시간, 대기 시간 등 분포를 분석할 값

```python
# 작업 완료 시간 기록
machine_stats.record_histogram("processing_time", actual_process_time)

# 품질 점수 기록
machine_stats.record_histogram("quality_score", quality_measurement)
```

### 2. 제조업 특화 이벤트 기록

#### 생산 완료 이벤트
```python
# 양품 생산 완료
machine_stats.record_manufacturing_event(
    "production_completed",
    quality="good"
)

# 불량품 생산
machine_stats.record_manufacturing_event(
    "production_completed", 
    quality="defective"
)
```

#### 설비 고장 이벤트
```python
# 설비 고장 발생
machine_stats.record_manufacturing_event(
    "machine_failure",
    duration=120  # 고장 지속 시간 (분)
)
```

#### 유지보수 완료 이벤트
```python
# 유지보수 완료
machine_stats.record_manufacturing_event(
    "maintenance_completed",
    duration=60   # 유지보수 시간 (분)
)
```

#### 품질 검사 이벤트
```python
# 품질 검사 결과
machine_stats.record_manufacturing_event(
    "quality_check",
    score=95.5    # 품질 점수
)
```

---

## 🏭 제조업 KPI 계산

### 1. OEE (Overall Equipment Effectiveness) 계산

OEE는 제조업에서 가장 중요한 KPI 중 하나로, 가용성 × 성능 × 품질로 계산됩니다.

```python
# 개별 요소 계산
availability = machine_stats.calculate_availability(
    planned_time=480,    # 계획된 가동 시간 (분)
    downtime=30         # 실제 정지 시간 (분)
)

performance = machine_stats.calculate_performance_efficiency(
    ideal_cycle_time=2.0,      # 이상적인 사이클 타임 (분)
    actual_cycle_time=140.0,   # 실제 소요 시간 (분)
    units_produced=65          # 생산 수량
)

# OEE 계산 (품질률은 별도 계산 필요)
quality_rate = 98.5  # 품질률 (%)
oee = machine_stats.calculate_oee(availability, performance, quality_rate)

print(f"계산된 OEE: {oee:.2f}%")
```

### 2. 자동 KPI 계산

중앙 통계 관리자가 자동으로 주요 KPI를 계산합니다:

```python
# 특정 컴포넌트의 OEE 자동 계산
oee_value = stats_manager.calculate_manufacturing_kpi("machine_001", "oee")

# 일발 양품률 계산
fpy_value = stats_manager.calculate_manufacturing_kpi("machine_001", "first_pass_yield")

# 불량률 계산
defect_rate = stats_manager.calculate_manufacturing_kpi("machine_001", "defect_rate")
```

---

## 🚨 실시간 알림 시스템

### 1. 알림 콜백 등록

임계값을 초과하면 자동으로 호출되는 콜백 함수를 등록할 수 있습니다:

```python
def alert_handler(alert):
    """알림 처리 함수"""
    print(f"🚨 알림 발생!")
    print(f"컴포넌트: {alert.component_id}")
    print(f"메트릭: {alert.metric_name}")
    print(f"심각도: {alert.severity.value}")
    print(f"현재값: {alert.current_value}")
    print(f"임계값: {alert.threshold_value}")
    print(f"메시지: {alert.message}")
    
    # 필요시 추가 조치 (이메일 발송, 로그 기록 등)
    if alert.severity.value == "critical":
        send_emergency_notification(alert)

# 알림 콜백 등록
stats_manager.register_alert_callback(alert_handler)
```

### 2. 활성 알림 조회

```python
# 전체 시스템의 실시간 대시보드 데이터
dashboard_data = stats_manager.get_real_time_dashboard_data()
print(f"시스템 상태: {dashboard_data['system_status']}")
print(f"활성 알림 수: {len(dashboard_data['alerts'])}")

# 특정 컴포넌트의 해결되지 않은 알림
component = stats_manager.components["machine_001"]
unresolved_alerts = component.get_unresolved_alerts()
for alert in unresolved_alerts:
    print(f"미해결 알림: {alert.message}")
```

---

## 📊 통계 조회 및 분석

### 1. 컴포넌트별 통계 조회

```python
# 기본 통계 조회 (하위 호환성)
stats = machine_stats.get_statistics()

# KPI 포함 상세 통계 조회
detailed_stats = stats_manager.get_component_statistics(
    "machine_001", 
    include_kpis=True
)

# KPI 대시보드 데이터
kpi_dashboard = machine_stats.get_kpi_dashboard()
```

### 2. 전체 시스템 통계

```python
# 제조업 요약 포함 전체 통계
global_stats = stats_manager.get_global_statistics(
    include_manufacturing_summary=True
)

# 시스템 성능 요약
performance_summary = stats_manager.get_system_performance_summary()
print(f"전체 OEE: {global_stats['manufacturing_summary']['overall_oee']:.2f}%")
print(f"시스템 상태: {performance_summary['health_status']}")
```

### 3. 성능 트렌드 분석

```python
# 특정 메트릭의 24시간 트렌드 분석
trend_analysis = stats_manager.get_performance_trends(
    component_id="machine_001",
    metric_name="processing_time",
    hours=24
)

print(f"트렌드 방향: {trend_analysis['trend']['direction']}")
print(f"데이터 포인트 수: {trend_analysis['data_points']}")
```

### 4. 성능 분석

```python
# 컴포넌트 성능 분석 (트렌드, 이상치 등)
performance_analysis = stats_manager.get_component_performance_analysis("machine_001")

# 처리 시간 트렌드
processing_trend = performance_analysis['trend_analysis']['processing_time']
print(f"처리 시간 트렌드: {processing_trend['direction']}")

# 이상치 감지
outlier_info = performance_analysis['outlier_detection']['processing_time']
print(f"이상치 비율: {outlier_info['outlier_percentage']:.2f}%")
```

---

## 💾 데이터 관리

### 1. 데이터 내보내기

```python
# 모든 컴포넌트 데이터 내보내기
export_data = stats_manager.export_statistics(
    component_ids=None,        # None이면 전체
    include_time_series=True   # 시계열 데이터 포함
)

# 특정 컴포넌트만 내보내기
export_data = stats_manager.export_statistics(
    component_ids=["machine_001", "machine_002"],
    include_time_series=False
)

# JSON 파일로 저장
import json
with open("statistics_export.json", "w") as f:
    json.dump(export_data, f, indent=2)
```

### 2. 데이터 정리

```python
# 48시간 이전 데이터 자동 정리
stats_manager.cleanup_old_data(max_age_hours=48)

# 특정 컴포넌트 데이터 삭제
stats_manager.clear_statistics(component_id="old_machine")

# 전체 데이터 초기화
stats_manager.clear_statistics()
```

---

## 🔧 고급 설정

### 1. 사용자 정의 메트릭 정의

```python
from src.core.centralized_statistics import MetricDefinition, MetricType

# 사용자 정의 메트릭 정의
custom_metric = MetricDefinition(
    name="custom_efficiency",
    metric_type=MetricType.RATE,
    description="사용자 정의 효율성 지표",
    unit="%",
    threshold_config={
        "low": 70.0,
        "medium": 85.0, 
        "high": 95.0
    },
    ttl_seconds=7200,  # 2시간 TTL
    is_kpi=True
)

# 메트릭 정의 등록
stats_manager.metric_definitions["custom_efficiency"] = custom_metric
```

### 2. 메모리 최적화 설정

```python
# 컴포넌트별 최대 히스토리 크기 설정
optimized_component = stats_manager.register_component(
    component_id="memory_optimized_machine",
    component_type="cnc_machine",
    max_history_size=5000  # 기본값: 10000
)
```

---

## 🔄 기존 코드와의 호환성

### 하위 호환성 보장

새로운 통계 시스템은 기존 코드와 완전히 호환됩니다:

```python
# 기존 방식 (계속 동작)
legacy_stats = machine_stats.get_statistics()

# 새로운 방식 (추가 기능)
enhanced_stats = stats_manager.get_component_statistics(
    "machine_001", 
    include_kpis=True
)

# 두 방식 모두 동일한 기본 데이터 포함
assert legacy_stats['simulation_time'] == enhanced_stats['simulation_time']
```

### 점진적 마이그레이션

1. **1단계**: 기존 코드는 그대로 두고 새로운 기능만 추가 사용
2. **2단계**: 새로운 제조업 특화 메트릭 도입
3. **3단계**: 실시간 알림 시스템 활용
4. **4단계**: 고급 분석 기능 활용

---

## 🔍 문제 해결

### 일반적인 문제와 해결책

#### 1. 메모리 사용량이 높을 때
```python
# 오래된 데이터 정리
stats_manager.cleanup_old_data(max_age_hours=24)

# 히스토리 크기 제한
stats_manager.register_component(
    "memory_efficient_component",
    "machine",
    max_history_size=1000
)
```

#### 2. 알림이 너무 많이 발생할 때
```python
# 알림 임계값 조정
metric_def = stats_manager.metric_definitions["queue_length"]
metric_def.threshold_config = {
    "high": 100,     # 기존: 50
    "critical": 200  # 기존: 100
}
```

#### 3. 성능이 느릴 때
```python
# 통계 수집 빈도 조정
# 중요하지 않은 메트릭은 덜 자주 수집
if env.now % 10 == 0:  # 10초마다만 수집
    machine_stats.record_gauge("non_critical_metric", value)
```

---

## ✨ 모범 사례

### 1. 메트릭 명명 규칙
- **일관성**: 동일한 유형의 메트릭은 동일한 접미사 사용
  - `*_count` (카운터), `*_rate` (비율), `*_time` (시간)
- **명확성**: 메트릭 이름만으로 의미를 알 수 있도록
- **표준화**: 가능한 미리 정의된 표준 메트릭 사용

### 2. 알림 설정
- **단계적 임계값**: low → medium → high → critical 순으로 설정
- **비즈니스 중요도**: 비즈니스에 미치는 영향에 따라 심각도 결정
- **액션 가능**: 알림 발생 시 취할 수 있는 구체적 조치가 있는 경우만 설정

### 3. 성능 최적화
- **배치 처리**: 가능한 여러 메트릭을 한 번에 기록
- **조건부 수집**: 중요하지 않은 메트릭은 특정 조건에서만 수집
- **정기 정리**: 오래된 데이터는 정기적으로 정리

---

## 📚 추가 자료

### 관련 문서
- [SimPy 공식 문서](https://simpy.readthedocs.io/)
- [제조업 KPI 가이드](./제조업_KPI_가이드.md)
- [시각화 시스템 가이드](./visualization_PRD.md)

### 예제 코드
- `examples/enhanced_statistics_example.py` - 향상된 통계 시스템 사용 예제
- `examples/manufacturing_kpi_example.py` - 제조업 KPI 계산 예제
- `examples/real_time_monitoring_example.py` - 실시간 모니터링 예제

---

**마지막 업데이트**: 2025년 7월 20일  
**문서 버전**: 1.0  
**작성자**: GitHub Copilot
