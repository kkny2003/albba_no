# 간단한 로깅 프레임워크 사용 가이드

## 개요

기존의 복잡한 로깅 방법을 간단하고 직관적인 방법으로 대체하는 로깅 프레임워크입니다. 모든 로그는 자동으로 마크다운 파일로 저장됩니다.

## 주요 특징

- **간단한 사용법**: 복잡한 설정 없이 바로 사용 가능
- **자동 MD 저장**: 모든 로그가 마크다운 형식으로 자동 저장
- **다양한 포맷**: 기본, 상세, 텍스트 포맷 지원
- **오류 처리**: 자동으로 오류 정보도 로그에 포함
- **메타데이터 지원**: 추가 정보를 로그와 함께 저장

## 설치 및 import

```python
from src.utils.log_util import LogContext, log_execution, quick_log
```

## 사용 방법

### 1. 컨텍스트 매니저 사용 (가장 간단)

```python
from src.utils.log_util import LogContext

# 기본 사용법
with LogContext("시뮬레이션_이름"):
    print("시뮬레이션 시작")
    print("데이터 처리 중...")
    result = calculate_something()
    print(f"결과: {result}")
```

### 2. 데코레이터 사용 (함수 전체 로깅)

```python
from src.utils.log_util import log_execution

@log_execution("함수_이름")
def my_function():
    print("함수 실행 중...")
    return "결과"
```

### 3. 메타데이터와 함께 사용

```python
metadata = {
    "시뮬레이션_타입": "성능_테스트",
    "데이터_크기": 1000,
    "실행_환경": "개발_서버"
}

with LogContext("테스트", metadata=metadata):
    print("메타데이터가 포함된 로깅")
```

### 4. 빠른 로그 저장

```python
from src.utils.log_util import quick_log

content = """
# 로그 내용

이것은 빠른 로그 저장 예제입니다.
"""

filename = quick_log("빠른_로그", content)
```

### 5. 커스텀 로그 매니저

```python
from src.utils.log_util import LogManager, LogContext

# 상세한 포맷으로 커스텀 설정
custom_log_manager = LogManager(
    log_dir="custom_logs",
    filename_pattern="detailed_{name}_{timestamp}.md",
    format_type="detailed_md"
)

with LogContext("커스텀_테스트", custom_log_manager):
    print("커스텀 설정으로 로깅")
```

## 포맷 타입

### 1. basic_md (기본값)
- 간단한 마크다운 형식
- 실행 시간, 메타데이터, 로그 내용 포함

### 2. detailed_md
- 상세한 마크다운 형식
- 테이블 형태의 메타데이터
- 요약 정보 포함

### 3. simple_text
- 간단한 텍스트 형식
- 마크다운 문법 없음

## 기존 코드와의 비교

### 기존 방법 (복잡함)
```python
# 복잡한 설정과 수동 관리
output_capture = io.StringIO()
original_stdout = sys.stdout
try:
    sys.stdout = output_capture
    # 시뮬레이션 코드
    run_simulation()
finally:
    sys.stdout = original_stdout
    captured_output = output_capture.getvalue()
    output_capture.close()
    save_output_to_md(captured_output)
    print(captured_output)
```

### 새로운 방법 (간단함)
```python
# 간단한 데코레이터 사용
@log_execution("시뮬레이션")
def run_simulation():
    # 시뮬레이션 코드
    pass
```

## 실제 사용 예제

### scenario.py에서의 사용

```python
@log_execution("냉장고_제조공정_시뮬레이션")
def main():
    """메인 실행 함수 - 간단한 로깅 적용"""
    print("### 냉장고 제조공정 시뮬레이션 초기화 ###")
    # ... 시뮬레이션 코드 ...
    print("### 시뮬레이션 완료 ###")
```

### 부분 로깅

```python
def complex_function():
    print("일반 출력")
    
    with LogContext("중요한_부분"):
        print("이 부분만 로그로 저장됨")
        # 중요한 계산이나 처리
    
    print("다시 일반 출력")
```

## 로그 파일 위치

- **기본**: `log/` 디렉토리
- **커스텀**: 설정한 디렉토리
- **파일명**: `{이름}_{타임스탬프}.md`

## 오류 처리

오류가 발생하면 자동으로 다음 정보가 로그에 포함됩니다:
- 오류 타입
- 오류 메시지
- 스택 트레이스

```python
@log_execution("오류_테스트")
def function_with_error():
    print("정상적인 작업")
    raise ValueError("의도적인 오류")
    # 오류 정보가 자동으로 로그에 포함됨
```

## 고급 기능

### 1. 여러 로그 매니저 동시 사용

```python
basic_manager = LogManager(format_type="basic_md")
detailed_manager = LogManager(format_type="detailed_md")

with LogContext("기본_로그", basic_manager):
    print("기본 포맷으로 로깅")

with LogContext("상세_로그", detailed_manager):
    print("상세 포맷으로 로깅")
```

### 2. 조건부 로깅

```python
import logging

if logging.getLogger().level <= logging.INFO:
    with LogContext("디버그_정보"):
        print("디버그 정보 출력")
```

## 장점

1. **간단함**: 복잡한 설정 없이 바로 사용
2. **자동화**: 모든 출력이 자동으로 캡처되고 저장
3. **유연성**: 다양한 포맷과 설정 옵션
4. **안정성**: 오류 처리와 예외 상황 대응
5. **가독성**: 마크다운 형식으로 깔끔한 로그

## 주의사항

1. **중첩 사용**: LogContext를 중첩해서 사용할 때 주의
2. **메모리 사용**: 대용량 출력 시 메모리 사용량 고려
3. **파일 권한**: 로그 디렉토리의 쓰기 권한 확인

## 마이그레이션 가이드

기존 코드를 새로운 프레임워크로 마이그레이션하는 방법:

1. **함수 전체 로깅**: `@log_execution` 데코레이터 추가
2. **부분 로깅**: `with LogContext():` 블록으로 감싸기
3. **기존 로그 코드 제거**: 수동 출력 캡처 코드 삭제
4. **테스트**: 로그 파일이 올바르게 생성되는지 확인

이제 복잡한 로깅 코드 없이도 깔끔하고 체계적인 로그를 생성할 수 있습니다!
