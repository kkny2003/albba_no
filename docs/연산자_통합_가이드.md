# 연산자 통합 가이드

## 개요

제조공정 시뮬레이션 프레임워크의 연산자 기능이 `src/Flow/operators.py`로 통합되었습니다. 이 문서는 통합된 연산자 시스템의 구조와 사용법을 설명합니다.

## 통합 배경

### 기존 문제점
- `__rshift__` 연산자가 여러 파일에 중복 정의되어 있었음
  - `src/Flow/process_chain.py`
  - `src/Flow/multi_group_flow.py`
  - `src/Flow/operators.py`
- 코드 중복으로 인한 유지보수 어려움
- 연산자 로직의 일관성 보장 어려움

### 통합 목표
- 모든 연산자 로직을 `operators.py`에서 중앙 관리
- 코드 중복 제거
- 일관된 연산자 동작 보장
- 확장성과 유지보수성 향상

## 통합된 연산자 시스템

### 지원하는 연산자

#### 1. `>>` 연산자 (순차 연결)
- **기능**: 공정들을 순차적으로 연결하여 ProcessChain 생성
- **지원 타입**:
  - `BaseProcess >> BaseProcess`
  - `BaseProcess >> ProcessChain`
  - `BaseProcess >> MultiProcessGroup`
  - `ProcessChain >> BaseProcess`
  - `ProcessChain >> ProcessChain`
  - `ProcessChain >> MultiProcessGroup`
  - `MultiProcessGroup >> BaseProcess`
  - `MultiProcessGroup >> ProcessChain`
  - `MultiProcessGroup >> MultiProcessGroup`

#### 2. `&` 연산자 (병렬 그룹)
- **기능**: 공정들을 병렬로 실행하는 MultiProcessGroup 생성
- **지원 타입**:
  - `BaseProcess & BaseProcess`
  - `ProcessChain & BaseProcess`
  - `MultiProcessGroup & BaseProcess`

### 연산자 구현 함수

#### BaseProcess 연산자
```python
def create_process_chain(left: BaseProcess, right: Union[BaseProcess, ProcessChain, MultiProcessGroup]) -> ProcessChain:
    """BaseProcess의 >> 연산자 구현"""

def create_multi_process_group(left: BaseProcess, right: BaseProcess) -> MultiProcessGroup:
    """BaseProcess의 & 연산자 구현"""
```

#### ProcessChain 연산자
```python
def chain_rshift(self, other: Union[BaseProcess, ProcessChain, MultiProcessGroup]) -> ProcessChain:
    """ProcessChain의 >> 연산자 구현"""

def chain_and(self, other: BaseProcess) -> MultiProcessGroup:
    """ProcessChain의 & 연산자 구현"""
```

#### MultiProcessGroup 연산자
```python
def group_rshift(self, other: Union[BaseProcess, ProcessChain, MultiProcessGroup]) -> ProcessChain:
    """MultiProcessGroup의 >> 연산자 구현"""

def group_and(self, other: BaseProcess) -> MultiProcessGroup:
    """MultiProcessGroup의 & 연산자 구현 (우선순위 지원)"""
```

## 동적 연산자 추가 시스템

### `add_operators_to_all_classes()` 함수
모든 공정 클래스에 연산자를 동적으로 추가하는 함수입니다.

```python
def add_operators_to_all_classes():
    """모든 공정 클래스에 연산자 메서드를 동적으로 추가합니다."""
    # BaseProcess 연산자
    BaseProcess.__rshift__ = base_rshift
    BaseProcess.__and__ = base_and
    
    # ProcessChain 연산자
    ProcessChain.__rshift__ = chain_rshift
    ProcessChain.__and__ = chain_and
    
    # MultiProcessGroup 연산자
    MultiProcessGroup.__rshift__ = group_rshift
    MultiProcessGroup.__and__ = group_and
```

### 자동 실행
`operators.py` 모듈이 로드될 때 자동으로 `add_operators_to_all_classes()`가 실행되어 모든 클래스에 연산자가 추가됩니다.

## 사용 예제

### 기본 연산자 사용
```python
import simpy
from src.Processes.manufacturing_process import ManufacturingProcess
from src.Processes.assembly_process import AssemblyProcess
from src.Resource.machine import Machine
from src.Resource.worker import Worker

# 환경 및 자원 설정
env = simpy.Environment()
machine1 = Machine(env, "machine1", "기계1", capacity=1)
machine2 = Machine(env, "machine2", "기계2", capacity=1)
worker1 = Worker(env, "worker1", "작업자1")
worker2 = Worker(env, "worker2", "작업자2")

# 공정 생성
process1 = ManufacturingProcess(
    env=env, process_id="process1", process_name="제조공정1",
    machines=[machine1], workers=[worker1],
    input_resources=[], output_resources=[], resource_requirements=[]
)

process2 = AssemblyProcess(
    env=env, process_id="process2", process_name="조립공정2",
    machines=[machine2], workers=[worker2],
    input_resources=[], output_resources=[], resource_requirements=[]
)

# 연산자 사용
chain = process1 >> process2  # 순차 연결
group = process1 & process2   # 병렬 그룹
```

### 복합 연산자 체인
```python
# 복잡한 공정 체인 구성
complex_chain = process1 >> (process2 & process3) >> process4
# 결과: process1 → [process2 & process3] → process4
```

### 우선순위 지원
```python
# 우선순위가 포함된 공정명
priority_process1 = ManufacturingProcess(
    env=env, process_id="process5", process_name="우선공정(1)",
    machines=[machine1], workers=[worker1],
    input_resources=[], output_resources=[], resource_requirements=[]
)

priority_process2 = ManufacturingProcess(
    env=env, process_id="process6", process_name="우선공정(2)",
    machines=[machine2], workers=[worker2],
    input_resources=[], output_resources=[], resource_requirements=[]
)

# 우선순위 그룹 생성
priority_group = priority_process1 & priority_process2
```

## 우선순위 시스템

### 우선순위 문법
- 공정명에 `(우선순위)` 형태로 우선순위 지정
- 예: `"제조공정(1)"`, `"조립공정(2)"`

### 우선순위 규칙
1. **전체 일관성**: 모든 공정에 우선순위를 지정하거나 모든 공정에서 우선순위를 생략해야 함
2. **순차 번호**: n개 공정이 있을 때, 우선순위는 1부터 n까지여야 함
3. **중복 금지**: 중복된 우선순위는 허용되지 않음

### 우선순위 검증
```python
from src.Processes.base_process import parse_process_priority, validate_priority_sequence

# 우선순위 파싱
name, priority = parse_process_priority("공정명(1)")
# 결과: ("공정명", 1)

# 우선순위 검증
processes_with_priorities = [(process1, 1), (process2, 2)]
validate_priority_sequence(processes_with_priorities)
```

## GroupWrapperProcess

### 역할
`MultiProcessGroup`을 `BaseProcess`로 래핑하여 ProcessChain에 포함시킬 수 있게 하는 클래스입니다.

### 동작 방식
1. `MultiProcessGroup`을 `GroupWrapperProcess`로 감쌈
2. `GroupWrapperProcess`는 `BaseProcess`를 상속받아 ProcessChain에 추가 가능
3. 실행 시 그룹의 `execute` 메서드를 호출하여 병렬 실행

### 사용 예제
```python
# MultiProcessGroup을 ProcessChain에 연결
group = process1 & process2
chain = group >> process3
# 내부적으로 GroupWrapperProcess가 생성되어 chain에 추가됨
```

## 에러 처리

### TypeError
- 지원되지 않는 타입의 객체와 연산자 사용 시 발생
- 명확한 에러 메시지로 문제 해결 가이드 제공

### PriorityValidationError
- 우선순위 규칙 위반 시 발생
- 구체적인 문제점과 해결 방법 제시

## 성능 고려사항

### 메모리 효율성
- 연산자 사용 시 새로운 객체 생성 최소화
- 기존 객체의 복사본 생성으로 원본 보존

### 실행 효율성
- 동적 연산자 추가로 런타임 오버헤드 최소화
- 연산자 로직의 최적화된 구현

## 확장성

### 새로운 연산자 추가
1. `operators.py`에 새로운 연산자 함수 구현
2. `add_operators_to_all_classes()`에 연산자 추가
3. 필요한 클래스에 동적으로 메서드 할당

### 새로운 클래스 지원
1. 새로운 공정 클래스 생성
2. `add_operators_to_all_classes()`에 클래스 추가
3. 해당 클래스에 필요한 연산자 할당

## 마이그레이션 가이드

### 기존 코드 호환성
- 기존 연산자 사용 코드는 변경 없이 동작
- 모든 연산자 기능이 그대로 유지됨

### 권장사항
- 새로운 코드 작성 시 `operators.py`의 통합된 연산자 사용
- 기존 코드도 점진적으로 통합된 연산자 시스템 활용

## 결론

연산자 통합을 통해 다음과 같은 이점을 얻었습니다:

1. **코드 중복 제거**: 모든 연산자 로직이 한 곳에서 관리
2. **일관성 보장**: 모든 클래스에서 동일한 연산자 동작
3. **유지보수성 향상**: 연산자 수정 시 한 곳만 변경하면 됨
4. **확장성 개선**: 새로운 연산자나 클래스 추가가 용이
5. **가독성 향상**: 연산자 로직의 명확한 구조화

이제 모든 연산자 관련 작업은 `src/Flow/operators.py`에서 중앙 관리되며, 프레임워크의 안정성과 확장성이 크게 향상되었습니다. 